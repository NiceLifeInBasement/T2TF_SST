Most relevant data seems to be in topic /tracked_objects/scan
    >boxes>[i]>box>header>...
    this contains x,y coordinates, angle, length and width along with velocity information

    probably need to use this when looking for information to fuse


think about what coordinate system you will use, or if this is basically predetermined by the way the data is given
    and in general how relevant the coordinate system ends up being (can be really annoying to deal with)

maybe start by using covariance intersection (CI) or FCI/I-FCI, try to get that running as a baseline
    since CI (variants) come with pretty clean formulas to implement
    and not a lot of data is needed for CI (see seeliger slides)
    from my current perspective this looks like the most promising algorithm for a baseline
    dont try CI, go for FCI or I-FCI
        if I-FCI is only changing the w approximation (as described in diss_seelinger:eq 4.16 (p.58) use that probably
        since it should just be the overall better solution

    but maybe FCI is enough as a baseline and is slightly easier to implement
    put the w calc into its own formula, pass an argument (or set some flag or something) to differentiate between
    CI/FCI/I-FCI/other ways of determining the w value, since that is the main difference between the variants

Issue: highly detailed data such as kalman gains from specific filters is not available, therefore certain algorithms
can not be implemented at all.
    " Die Methoden [ohne Zusatzinformation] werden in dieser Arbeit der Vollständigkeit halber vorgestellt,
    da mit den Methoden ohne Zusatzinformation nur ein geringer, z.T. auch prinzipbedingt gar kein
    Informationsgewinn realisiert werden kann" (src: Diss_Seelinger, p53, intro to section 4)
    --> Problem.

https://scicomp.stackexchange.com/questions/22105/complexity-of-matrix-inversion-in-numpy
    notes on matrix inversion speed, including when to use the inversion and when NOT to use the inversion
    ("need to compute a product A−1b, you should instead solve the linear system Ax=b (e.g., using numpy.linalg.solve")